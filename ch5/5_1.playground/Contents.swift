import UIKit

/*
 할당(대입) 연산자 - 서로 다른 데이터 타입이라면 오류가 발생한다
 A = B
 
 
 산술 연산자 - 수학에서 쓰이는 연산자와 같은 역할, 스위프트에서는 부동소수점의 나머지 연산을 지원(truncatingRemainder 사용)
 A + B
 A - B
 A * B
 A / B
 A % B
 ex) var result: Double = number.truncatingRemainder(dividingBy: 1.5) -> Double형일 경우 사용
 
 
 비교 연산자 - 두 값을 비교할 때 사용
 A == B
 A >= B
 A <= B
 A > B
 A < B
 A != B (A와 B가 같지 않다)
 A === B (참조가 같다) -> A와 B가 참조(래퍼런스) 타입일 떼 A와 B가 같은 인스턴스를 가르키는지 비교하여 불리안 값 반환
 A !== B (참조가 같지 않다)
 A ~= B (패턴 매치) -> A와 B의 패턴이 매치되는지 확인하여 불리안 값을 반환
 
 
 삼항 연산지 - 피연산가자 세 대인 삼항 조건 연산자
 Question ? A : B -> Question이 참이면 A, 거짓이면 B 반환
 
 
 범위 연산자 - 값의 범위를 나타내고자 할 때 사용
 (폐쇄 범위 연산자)
 A...B -> A부터 B까지의 수를 묶어 범위를 표현(A와 B를 포함)
 (반폐쇄 범위 연산자)
 A.. <B -> A부터 B미만까지의 수를 묶어 범위를 표현(A를 포함 B는 포함하지 않는다)
 (단방향 범위 연산자)
 A... -> A 이상의 수를 묶어 범위를 표현(A 포함)
 ...A -> A 이하의 수를 묶어 범위를 표현(A 포함)
 ..<A -> A 미만의 수를 묶어 범위를 표현(A 미포함)
 

 부울 연산자 - 불리언 값의 논리 연산을 할 때 사용
 (NOT(부정) 부울 연산자)
 !B -> B(불리언 값)의 참, 거짓을 반전함
 (AND 부울 연산자)
 A && B -> A와 B의 불리언 AND 논리 연산을 실행
 (OR 부울 연산자)
 A || B -> A와 B의 불리언 OR 논리 연산을 실헹
 
 비트 연산자
 (NOT(부정) 비트 연산자)
 ~A -> A의 비트를 반전한 결과를 반환
 (AND 비트 연산자)
 A & B -> A와 B의 비트 AND 논리 연산을 실행
 (OR 비트 연산자)
 A | B -> A와 B의 비트 OR 논리 연산을 실행
 (XOR 비트 연산자)
 A ^ B -> A와 B의 비트 XOR 논리 연산을 실행
 (비트 이동 연산자(시프트 연산자))
 A >> B -> A의 비트를 B만큼 비트를 시프트(이동)
 A << B
 
 
 복합 할당 연산자 - 할당 연산자와 다른 연산자가 하는 일을 한 번에 할 수 있도록 얀산자를 결합할 수 있다.
 A += B
 A -= B
 A *= B
 A /= B
 A %= B
 A <<= N -> A를 N만큼 왼쪽 비트 시프트 한 값을 A에 할당
 A >>= N
 A &= B -> AND 연산 결과를 A에 할당
 A |= B -> OR 연산 결과를 A에 할당
 A ^= B -> XOR 연산 결과를 A에 할당
 
 오버플로 연산자 - 기존 다른 언어는 따로 오버플로에 대한 추가 알고리즘 및 로직을 설계해야 했지만 스위프트에서는 오버플로 연산자를 사용하면 자동으로 처리함
 &+ -> 오버플로에 대비한 덧셈 연산을 합니다
 &-
 &*
 
 
 기타 연산자
 (nil 병합 연산자)
 A ?? B -> A가 nil이 아니면 A를 반환하고, nil이면 B를 반환
 (부호변경 연산자)
 -A -> A(수)의 부호를 변경
 (옵셔널 강제 추출 연산자)
 O! -> O(옵셔널 개체)의 값을 강제로 추출
 (옵셔널 연산자)
 V? -> V(옵셔널 값)를 안전하게 추출하거나, V(데이터 타입)가 옵셔널임을 표현
 
 
 
 
 
 
 
 
 
 
 */


let number: Double = 5.0
var result: Double = number.truncatingRemainder(dividingBy: 1.5)
result = 12.truncatingRemainder(dividingBy: 2.5)
